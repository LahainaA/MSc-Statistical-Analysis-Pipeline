<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Experiment 1: Practice 1</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #f0f2f5;
            color: #1a1b1c;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            width: 100%;
            max-width: 70vw;
            padding: 60px;
            box-sizing: border-box;
            position: relative;
        }

        header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            gap: 15px;
        }

        header h1 {
            font-size: 24px;
            margin: 0;
            color: #1a1b1c;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
        }

        input,
        button {
            padding: 10px 14px;
            border: 1px solid #ced4da;
            background: #fff;
            border-radius: 8px;
            color: #343a40;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input:focus,
        button:focus {
            outline: none;
            border-color: #4c6ef5;
            box-shadow: 0 0 0 2px rgba(76, 110, 245, 0.2);
        }

        input[type="number"] {
            width: 70px;
        }

        input[readonly] {
            background-color: #e9ecef;
            cursor: not-allowed;
        }

        button#downloadBtn:disabled {
            background-color: #e9ecef;
            cursor: not-allowed;
            color: #adb5bd;
        }

        #message {
            text-align: center;
            margin: 10px 0;
            color: #495057;
            min-height: 22px;
            font-size: 15px;
        }

        canvas {
            background: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            width: 100%;
            max-width: 650px;
            height: auto;
            aspect-ratio: 4 / 3;
            display: block;
            margin: 0 auto;
            box-shadow: 0 25px 20px rgba(0, 0, 0, 0.05);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #nextTrialBtn {
            display: none;
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4c6ef5;
            color: white;
            border: none;
            z-index: 1100;
        }



        #fullscreenOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
        }

        #enterFullscreen {
            padding: 16px 28px;
            font-size: 18px;
            border: none;
            background: #4c6ef5;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(248, 249, 250, 0.9);
            z-index: 999;
        }

        #overlay .card {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 16px;
            padding: 24px 28px;
            width: 90%;
            max-width: 520px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        #overlay h3 {
            margin: 0 0 8px;
            font-size: 22px;
        }

        #overlay p {
            margin: 0 0 16px;
            line-height: 1.5;
            color: #495057;
        }

        #continueBtn {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4c6ef5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        /* Fullscreen exit overlay */
        #fsExitOverlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
        }

        #fsExitOverlay .card {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 16px;
            padding: 24px 28px;
            width: 90%;
            max-width: 520px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        #returnFullscreenBtn {
            margin-top: 16px;
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4c6ef5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
    </style>
    <script type="text/javascript" src="imtScripts.js"></script>

</head>

<body>
    <div class="container">
        <header>
            <h1>Experiment 1: Practice 1</h1>
            <div class="controls">
                <label style="display: none;">Trials <input id="trialsInput" type="number" value="80" readonly></label>
                <label style="display: none;">Duration (sec) <input id="tInput" type="number" min="1" step="0.1"
                        value="3.7"></label>
                <label style="display: none;">Blank (ms) <input id="blankInput" type="number" min="0" step="50"
                        value="250" readonly></label>
                <label style="display: none;">Amplitude <input id="ampInput" type="number" min="0.025" max="0.25"
                        step="0.025" value="0.05"></label>
                <label style="display: none;">Cycles <input id="cyclesInput" type="number" min="1" step="1"
                        value="3"></label>
                <button id="downloadBtn" disabled style="display: none;">Download Data</button>
            </div>
        </header>

        <div id="message">Click "Start Experiment" to begin.</div>
        <canvas id="canvas" tabindex="0"></canvas>
        <button id="nextTrialBtn">Next Trial</button>
    </div>

    <div id="fullscreenOverlay">
        <button id="enterFullscreen">Start Practice 1</button>
    </div>

    <div id="overlay">
        <div class="card">
            <h3 id="ovlTitle">Practice 1: Instructions</h3>
            <p id="ovlBody"></p>
            <button id="continueBtn">Continue</button>
        </div>
    </div>

    <div id="fsExitOverlay" aria-live="polite">
        <div class="card">
            <h3>Practice Paused.</h3>
            <p>Full-screen mode is required. Please click below to continue the practice.</p>
            <button id="returnFullscreenBtn">Return to Fullscreen</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const msg = document.getElementById('message');
        const overlay = document.getElementById('overlay');
        const ovlTitle = document.getElementById('ovlTitle');
        const ovlBody = document.getElementById('ovlBody');
        const continueBtn = document.getElementById('continueBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const nextTrialBtn = document.getElementById('nextTrialBtn');
        const trialsInput = document.getElementById('trialsInput');
        const tInput = document.getElementById('tInput');
        const blankInput = document.getElementById('blankInput');
        const ampInput = document.getElementById('ampInput');
        const cyclesInput = document.getElementById('cyclesInput');

        const fsExitOverlay = document.getElementById('fsExitOverlay');
        const returnFullscreenBtn = document.getElementById('returnFullscreenBtn');

        // --- Canvas and Geometry Scaling ---
        let canvasWidth, canvasHeight, midX, midY, pathWidth, pathHeight;

        // --- PARAMETERS ---
        const FIXED_BLANK_MS = 250; // Fixed Retention Interval (RI) at 250ms
        const CLICK_SNAP_CM = 0.5; // Click Snapping Threshold (0.5cm)
        let CLICK_SNAP_PX;
        // ------------------------------------

        //IMT stuff
        var sessionStart = pad(Date.now(), 16);
        var sessionKey = pad(Math.floor(Math.random() * 1000), 4);
        var uniqueID = sessionStart + "_" + sessionKey;
        var thisParam1;
        var thisParam2;
        var thisParam3;
        var thisParam4;
        var thisParam5;

        if (thisParam1 = getUrlParameter('ID')) {
            sessionStart = thisParam1;
        } else {
            sessionStart = pad(Date.now(), 16);
        }

        if (thisParam2 = getUrlParameter('SESSION')) {
            sessionKey = thisParam2;
        } else {
            sessionKey = Math.floor(Math.random() * 1000);
            sessionKey = pad(sessionKey, 4);
        }

        if ((thisParam3 = getUrlParameter('SOURCE')) == "PROLIFIC") {
            sourceString = "&SOURCE=PROLIFIC";
        } else {
            sourceString = "&SOURCE=0";
        }

        if (thisParam4 = getUrlParameter('DATA')) {
            if (thisParam4 == 0) {
                dataString = "&DATA=0";
            } else {
                dataString = "&DATA=1";
            }
        } else {
            dataString = "&DATA=1";
        }



        uniqueID = sessionStart + "_" + sessionKey;


        // Freeze canvas size during experiment so leaving fullscreen doesn't rescale anything
        let FREEZE_CANVAS_SIZE = false;

        function cmToPixels(cm) {
            // Standard assumption: 96 pixels per inch (PPI) for CSS pixels
            const inches = cm / 2.54;
            const dpi = 96;
            // We multiply by devicePixelRatio to work in the canvas's coordinate system
            return inches * dpi * window.devicePixelRatio;
        }

        function resizeCanvas() {
            if (FREEZE_CANVAS_SIZE) return;

            const canvasContainer = document.querySelector('.container');
            const containerWidth = canvasContainer.clientWidth;

            const cssMaxWidth = 650; // JS function now respects the 650px CSS max-width
            // The size is the *smaller* of the container width and our max width
            // And it can't be smaller than 300px.
            const size = Math.max(300, Math.min(containerWidth, cssMaxWidth));

            const aspectRatio = 4 / 3;

            canvas.width = size * window.devicePixelRatio;
            canvas.height = (size / aspectRatio) * window.devicePixelRatio;

            canvas.style.width = `${size}px`;
            canvas.style.height = `${size / aspectRatio}px`;

            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
            midX = canvasWidth / 2;
            midY = canvasHeight / 2;

            const pathLength = Math.min(canvasWidth, canvasHeight) * 0.99;
            pathWidth = pathLength;
            pathHeight = pathWidth;

            SINE_AMPLITUDE = parseFloat(ampInput.value);
            SINE_CYCLES = parseFloat(cyclesInput.value);

            // Recalculate snap distance
            CLICK_SNAP_PX = cmToPixels(CLICK_SNAP_CM);
        }


        window.addEventListener('resize', resizeCanvas);

        // --- Parameters ---
        const dotR = 6 * window.devicePixelRatio; // Dot radius
        let DURATION_SEC, SINE_AMPLITUDE, SINE_CYCLES;
        const NORM_45 = 1 / Math.sqrt(2); // Normalization factor for 45 degrees
        const RESPONSE_WINDOW_MS = 6000; // Max time for user to click
        const INTER_TRIAL_BLANK_MS = 500; // Blank screen between trials
        const PRE_STIMULUS_DELAY = { min: 500, max: 1000 }; // Onset delay 500-1000ms
        // const TRIALS_PER_BLOCK = 20; // NO BREAKS IN PRACTICE
        const TARGET_FPS = 60; // Target animation framerate
        const FRAME_INTERVAL = 1000 / TARGET_FPS; // Duration of a single frame
        let BASE_SPEED_PX_PER_MS = 0; // Base speed, calculated in startExperiment

        // --- Arc Length and Path Integration Parameters ---
        let arcLengthCache = {}; // Cache stores {total: length, segments: [{p, length}, ...]}
        const ARC_STEPS = 500; // Number of segments for path integration
        const VANISH_WINDOW = { min: 0.6, max: 0.8 }; // Dot vanishes between 60% and 80% of path
        function sampleVanishP() {
            const range = VANISH_WINDOW.max - VANISH_WINDOW.min;
            const randomFactor = Math.random();
            return VANISH_WINDOW.min + randomFactor * range;
        }

        // --- State ---
        let running = false, trialIndex = 0, trials = [], dataRecords = [], animationFrameId;
        let experimentStartTimeCET;
        let EXPERIMENT_FINALIZED = false;
        let isTrialActive = false;

        // Mouse drift guard for response phase
        let driftGuard = {
            armed: false,
            start: null,
            moved: false
        };
        const DRIFT_GUARD_THRESHOLD = 3 * window.devicePixelRatio; // Max pixels mouse can move during click

        // Mouse move guard for animation phase
        let mouseMovedDuringAnimation = false;
        let armAnimationMouseGuard = false;
        const ANIMATION_MOVE_THRESHOLD = 8; // Max pixels mouse can move during animation

        // Fullscreen interrupt state
        let fullscreenInterrupted = false;
        let onFullscreenInterrupt = null; // Callback for when FS is interrupted

        // --- Helper Functions ---
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; }
        function clearCanvas() { ctx.clearRect(0, 0, canvasWidth, canvasHeight); }
        function delay(ms) { return new Promise(res => setTimeout(res, ms)); }
        function sampleDelay(range) { return range.min + Math.random() * (range.max - range.min); }
        function euclideanDist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }

        function getMousePosOnCanvas(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function areTrialsIdentical(t1, t2) {
            if (!t1 || !t2) return false;
            const sameBasic = t1.motionPath === t2.motionPath &&
                t1.pathGeometry === t2.pathGeometry &&
                t1.direction === t2.direction &&
                t1.pathVisibility === t2.pathVisibility;
            if (!sameBasic) return false;
            if (t1.pathGeometry !== 'sinusoidal') return true;
            return Math.abs((t1.phaseOffset || 0) - (t2.phaseOffset || 0)) < 1e-3;
        }

        function isDifferentCondition(a, b) {
            if (!a || !b) return false;
            return a.motionPath !== b.motionPath ||
                a.pathGeometry !== b.pathGeometry ||
                a.direction !== b.direction ||
                a.pathVisibility !== b.pathVisibility;
        }

        // --- Path Definitions ---
        const pathDefs = {
            'horizontal': {
                getPoint: (p, amp, angle) => ({ x: (midX - pathWidth / 2) + p * pathWidth, y: midY - amp * Math.sin(angle) }),
                dir: { x: 1, y: 0 }
            },
            'upward': {
                getPoint: (p, amp, angle) => {
                    const x_span = pathWidth * NORM_45;
                    const y_span = pathHeight * NORM_45;
                    const startX = midX - x_span / 2;
                    const startY = midY + y_span / 2;
                    return {
                        x: startX + p * x_span - amp * Math.sin(angle) * NORM_45,
                        y: startY - p * y_span - amp * Math.sin(angle) * NORM_45
                    };
                },
                dir: { x: NORM_45, y: -NORM_45 }
            },
            'downward': {
                getPoint: (p, amp, angle) => {
                    const x_span = pathWidth * NORM_45;
                    const y_span = pathHeight * NORM_45;
                    const startX = midX - x_span / 2;
                    const startY = midY - y_span / 2;
                    return {
                        x: startX + p * x_span - amp * Math.sin(angle) * NORM_45,
                        y: startY + p * y_span + amp * Math.sin(angle) * NORM_45
                    };
                },
                dir: { x: NORM_45, y: NORM_45 }
            }
        };

        // --- 1. Arc Length Cache Builder ---
        function buildArcLengthCache(tr) {
            const key = `${tr.motionPath}-${tr.pathGeometry}-${(tr.phaseOffset || 0).toFixed(4)}`;
            if (arcLengthCache[key]) return;

            const definition = pathDefs[tr.motionPath];
            const geometry = tr.pathGeometry;
            const phaseOffset = tr.phaseOffset || 0;
            const amp = (geometry === 'sinusoidal') ? pathWidth * SINE_AMPLITUDE : 0;

            let totalLength = 0;
            let segments = [];
            let prevPoint = definition.getPoint(0, amp, phaseOffset);

            for (let i = 1; i <= ARC_STEPS; i++) {
                const p_norm = i / ARC_STEPS;
                const angle = (geometry === 'sinusoidal') ? (SINE_CYCLES * p_norm * 2 * Math.PI + phaseOffset) : 0;
                const currentPoint = definition.getPoint(p_norm, amp, angle);

                const segmentLength = euclideanDist(prevPoint, currentPoint);
                totalLength += segmentLength;
                segments.push({ p: p_norm, length: totalLength });

                prevPoint = currentPoint;
            }

            arcLengthCache[key] = {
                total: totalLength,
                segments: segments
            };
        }

        // --- 2. Get Normalized Progress at True Arc Length ---
        function getPAtArcLength(tr, targetLength) {
            const key = `${tr.motionPath}-${tr.pathGeometry}-${(tr.phaseOffset || 0).toFixed(4)}`;
            const cache = arcLengthCache[key];
            if (!cache || !cache.total) return 0;

            if (targetLength <= 0) return 0;
            if (targetLength >= cache.total) return 1;

            let lowerSegment = { p: 0, length: 0 };
            let upperSegment = cache.segments[cache.segments.length - 1];

            // Binary search could be faster, but linear is fine for ARC_STEPS=500
            for (const seg of cache.segments) {
                if (seg.length <= targetLength) {
                    lowerSegment = seg;
                } else {
                    upperSegment = seg;
                    break;
                }
            }
            const lengthRange = upperSegment.length - lowerSegment.length;
            if (lengthRange === 0) return lowerSegment.p;

            const pRange = upperSegment.p - lowerSegment.p;
            const progressInSegment = (targetLength - lowerSegment.length) / lengthRange;

            return lowerSegment.p + progressInSegment * pRange;
        }

        // Converts a normalized progress 'p' (0-1) into a pixel distance
        function getArcLengthAtP(tr, p_target) {
            const key = `${tr.motionPath}-${tr.pathGeometry}-${(tr.phaseOffset || 0).toFixed(4)}`;
            const cache = arcLengthCache[key];
            if (!cache || !cache.total || p_target <= 0) return 0;
            if (p_target >= 1) return cache.total;

            let lowerSegment = { p: 0, length: 0 };
            let upperSegment = cache.segments[cache.segments.length - 1];

            for (const seg of cache.segments) {
                if (seg.p <= p_target) {
                    lowerSegment = seg;
                } else {
                    upperSegment = seg;
                    break;
                }
            }

            const pRange = upperSegment.p - lowerSegment.p;
            if (pRange === 0) return lowerSegment.length;

            const lengthRange = upperSegment.length - lowerSegment.length;
            const progressInSegment = (p_target - lowerSegment.p) / pRange;

            return lowerSegment.length + progressInSegment * lengthRange;
        }

        // --- Find Closest Point on Path ---
        function findClosestPointOnPath(tr, clickPoint) {
            const definition = pathDefs[tr.motionPath];
            const key = `${tr.motionPath}-${tr.pathGeometry}-${(tr.phaseOffset || 0).toFixed(4)}`;
            const cache = arcLengthCache[key];
            const totalLen = cache.total;

            const amp = (tr.pathGeometry === 'sinusoidal') ? pathWidth * SINE_AMPLITUDE : 0;
            const phase = tr.phaseOffset || 0;

            function pointAtP(p) {
                const angle = (tr.pathGeometry === 'sinusoidal')
                    ? (SINE_CYCLES * p * 2 * Math.PI + phase)
                    : 0;
                return definition.getPoint(p, amp, angle);
            }

            // 1. Coarse search
            const COARSE_STEPS = 300;
            let bestS = 0;
            let bestP = 0;
            let bestPt = pointAtP(0);
            let bestD = euclideanDist(clickPoint, bestPt);

            for (let i = 1; i <= COARSE_STEPS; i++) {
                const s = totalLen * (i / COARSE_STEPS);
                const p = getPAtArcLength(tr, s);
                const pt = pointAtP(p);
                const d = euclideanDist(clickPoint, pt);
                if (d < bestD) {
                    bestD = d; bestS = s; bestP = p; bestPt = pt;
                }
            }

            // 2. Fine (ternary) search in the local minimum
            let lo = Math.max(0, bestS - totalLen * 0.02);
            let hi = Math.min(totalLen, bestS + totalLen * 0.02);

            const REFINE_ITERS = 20;
            for (let k = 0; k < REFINE_ITERS; k++) {
                const m1 = lo + (hi - lo) / 3;
                const m2 = hi - (hi - lo) / 3;

                const p1 = getPAtArcLength(tr, m1);
                const pt1 = pointAtP(p1);
                const d1 = euclideanDist(clickPoint, pt1);

                const p2 = getPAtArcLength(tr, m2);
                const pt2 = pointAtP(p2);
                const d2 = euclideanDist(clickPoint, pt2);

                if (d1 < d2) {
                    hi = m2;
                    if (d1 < bestD) { bestD = d1; bestS = m1; bestP = p1; bestPt = pt1; }
                } else {
                    lo = m1;
                    if (d2 < bestD) { bestD = d2; bestS = m2; bestP = p2; bestPt = pt2; }
                }
            }

            return { p: bestP, point: bestPt, distance: bestD };
        }

        // drawTrack is used for both animation (if visible) and response (always)
        function drawTrack(tr) {
            const path = tr.motionPath;
            const geometry = tr.pathGeometry;
            const phaseOffset = tr.phaseOffset || 0;

            ctx.strokeStyle = '#1f2a44';
            ctx.lineWidth = 2 * window.devicePixelRatio;
            ctx.beginPath();
            const definition = pathDefs[path];
            const amp = (geometry === 'sinusoidal') ? pathWidth * SINE_AMPLITUDE : 0;
            const steps = 100;

            for (let i = 0; i <= steps; i++) {
                const p_norm = i / steps;
                const angle = (geometry === 'sinusoidal') ? (SINE_CYCLES * p_norm * 2 * Math.PI + phaseOffset) : 0;
                const currentPoint = definition.getPoint(p_norm, amp, angle);

                if (i === 0) ctx.moveTo(currentPoint.x, currentPoint.y);
                else ctx.lineTo(currentPoint.x, currentPoint.y);
            }
            ctx.stroke();
        }

        // --- Fullscreen and Experiment Start ---
        document.getElementById('enterFullscreen').addEventListener('click', async () => {
            document.getElementById('fullscreenOverlay').style.display = 'none';
            try { await document.documentElement.requestFullscreen?.(); } catch (err) { console.warn("Fullscreen request failed:", err); }
            resizeCanvas(); // Resize *after* entering fullscreen
            startExperiment();
        });

        function waitContinue() {
            return new Promise(res => {
                continueBtn.addEventListener('click', res, { once: true });
            });
        }

        // Fullscreen lifecycle handling
        function showFsOverlay() {
            fsExitOverlay.style.display = 'flex';
        }
        function hideFsOverlay() {
            fsExitOverlay.style.display = 'none';
        }
        function waitForFullscreen() {
            return new Promise(resolve => {
                if (document.fullscreenElement) return resolve();
                const handler = () => {
                    if (document.fullscreenElement) {
                        document.removeEventListener('fullscreenchange', handler);
                        resolve();
                    }
                };
                document.addEventListener('fullscreenchange', handler);
            });
        }
        returnFullscreenBtn.addEventListener('click', async () => {
            try { await document.documentElement.requestFullscreen?.(); } catch { }
        });

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && running) {
                fullscreenInterrupted = true;
                showFsOverlay();
                if (typeof onFullscreenInterrupt === 'function') {
                    onFullscreenInterrupt();
                }
            } else if (document.fullscreenElement && fullscreenInterrupted) {
                fullscreenInterrupted = false; // Reset the interruption flag
                hideFsOverlay();
            }
        });

        // --- Trial Structure ---
        function buildTrials() {
            // --- PRACTICE 1: 5 TRIALS (3 vis, 2 invis) ---
            const allTrialTypes = [
                // 3x Visible
                { motionPath: 'horizontal', pathGeometry: 'linear', pathVisibility: 'visible', direction: 1 },
                { motionPath: 'horizontal', pathGeometry: 'sinusoidal', pathVisibility: 'visible', direction: -1 },
                { motionPath: 'horizontal', pathGeometry: 'linear', pathVisibility: 'visible', direction: -1 },
                // 2x Invisible
                { motionPath: 'horizontal', pathGeometry: 'sinusoidal', pathVisibility: 'invisible', direction: 1 },
                { motionPath: 'horizontal', pathGeometry: 'linear', pathVisibility: 'invisible', direction: 1 }
            ];

            let trials = shuffle(allTrialTypes);

            return trials.map((t, i) => {
                const trial = { ...t, idx: i + 1, vanishP: sampleVanishP() }; // Use real vanish logic
                if (trial.pathGeometry === 'sinusoidal') {
                    trial.phaseOffset = Math.random() * 2 * Math.PI;
                } else {
                    trial.phaseOffset = 0;
                }
                return trial;
            });
        }

        // --- Core Trial Logic ---
        function handleError(message, resolve) {
            msg.textContent = message;
            document.body.style.cursor = 'default';
            nextTrialBtn.textContent = 'Continue';
            nextTrialBtn.style.display = 'block';

            nextTrialBtn.addEventListener('click', () => {
                nextTrialBtn.style.display = 'none';
                nextTrialBtn.textContent = 'Next Trial';
                onFullscreenInterrupt = null;
                resolve(false); // resolve(false) signals to the main loop to retry the trial
            }, { once: true });
        }

        function runOneTrial(tr, totalTrials) {
            return new Promise(resolve => {
                // Apply +/- 10% random speed variation
                const speedVariation = 0.90 + (Math.random() * 0.20);
                const speed_px_ms = BASE_SPEED_PX_PER_MS * speedVariation;

                const cacheKey = `${tr.motionPath}-${tr.pathGeometry}-${(tr.phaseOffset || 0).toFixed(4)}`;
                const totalPathLength = arcLengthCache[cacheKey].total;
                const startTS = performance.now();

                // Animation smoothing logic
                let lastFrameTime = startTS;
                let accumulatedTime = 0;
                let totalElapsed = 0; // This is the "true" animation time

                let vanished = false;
                let vanishPos = { x: null, y: null };
                let vanishArcLen = null;

                const definition = pathDefs[tr.motionPath];

                // Calculate random start offset (0-20% of path length)
                const randomStartOffsetPx = Math.random() * (totalPathLength * 0.20);

                // Calculate duration and vanish time based on the *visible* path
                const visiblePathLengthPx = totalPathLength - randomStartOffsetPx;
                const vanishTimeMs = (visiblePathLengthPx * tr.vanishP) / speed_px_ms; // tr.vanishP is random (0.6-0.8)


                // --- Animation Phase Mouse Guard ---
                mouseMovedDuringAnimation = false;
                armAnimationMouseGuard = false;
                isTrialActive = true;

                const handleAnimationMouseMove = (e) => {
                    if (!isTrialActive || !armAnimationMouseGuard) return;

                    const dx = e.movementX || 0;
                    const dy = e.movementY || 0;

                    if ((dx * dx + dy * dy) >= (ANIMATION_MOVE_THRESHOLD * ANIMATION_MOVE_THRESHOLD)) {
                        mouseMovedDuringAnimation = true;
                    }
                };

                document.addEventListener('mousemove', handleAnimationMouseMove);
                setTimeout(() => { armAnimationMouseGuard = true; }, 150);


                onFullscreenInterrupt = () => {
                    try { cancelAnimationFrame(animationFrameId); } catch { }
                    isTrialActive = false;
                    document.removeEventListener('mousemove', handleAnimationMouseMove);
                    canvas.removeEventListener('mousedown', onMouseDown);
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('click', onClick, true);
                    clearTimeout(clickPhase?.timeoutId);

                    msg.textContent = 'Fullscreen was exited. Click "Return to Fullscreen" to repeat this trial.';
                    resolve(false);
                    onFullscreenInterrupt = null;
                };

                let onMouseDown, onMouseMove, onClick, clickPhase;


                const frame = (now) => {
                    animationFrameId = requestAnimationFrame(frame);

                    // --- CHECK 1: Animation Mouse Move ---
                    if (mouseMovedDuringAnimation) {
                        cancelAnimationFrame(animationFrameId);
                        isTrialActive = false;
                        document.removeEventListener('mousemove', handleAnimationMouseMove);
                        handleError('Mouse moved during trial. Please click "Continue" to restart.', resolve);
                        return;
                    }

                    // --- CHECK 2: Fullscreen Exit ---
                    if (fullscreenInterrupted) {
                        cancelAnimationFrame(animationFrameId);
                        isTrialActive = false;
                        document.removeEventListener('mousemove', handleAnimationMouseMove);
                        onFullscreenInterrupt = null;
                        resolve(false);
                        return;
                    }

                    // --- Animation smoothing logic ---
                    const delta = now - lastFrameTime;
                    lastFrameTime = now;
                    accumulatedTime += delta;

                    // Run the update logic at a fixed 60Hz rate
                    while (accumulatedTime >= FRAME_INTERVAL) {
                        if (vanished) break; // Don't advance time if dot has vanished

                        totalElapsed += FRAME_INTERVAL; // This is the "true" animation time

                        // Check for vanish *before* drawing
                        if (!vanished && totalElapsed >= vanishTimeMs) {
                            vanished = true;

                            // Calculate precise vanish position based on vanishTimeMs
                            const vanishDistTravelled = speed_px_ms * vanishTimeMs + randomStartOffsetPx;
                            const cappedVanishDist = Math.min(vanishDistTravelled, totalPathLength);

                            vanishArcLen = (tr.direction === 1) ? cappedVanishDist : (totalPathLength - cappedVanishDist);

                            const p_norm_vanish = getPAtArcLength(tr, vanishArcLen);
                            const amp_vanish = (tr.pathGeometry === 'sinusoidal') ? pathWidth * SINE_AMPLITUDE : 0;
                            const angle_vanish = (tr.pathGeometry === 'sinusoidal') ? (SINE_CYCLES * p_norm_vanish * 2 * Math.PI + (tr.phaseOffset || 0)) : 0;
                            vanishPos = definition.getPoint(p_norm_vanish, amp_vanish, angle_vanish);

                            // Stop the animation loop
                            cancelAnimationFrame(animationFrameId);

                            // --- MODIFIED PROTOCOL (NO BLANK) ---
                            // 1. Stop animation and clear canvas
                            clearCanvas();

                            isTrialActive = false;
                            document.removeEventListener('mousemove', handleAnimationMouseMove);

                            // 2. Draw the track IMMEDIATELY
                            drawTrack(tr);

                            // 3. Draw the RED dot where the dot stopped
                            ctx.fillStyle = '#FF0000'; // Red
                            ctx.beginPath();
                            ctx.arc(vanishPos.x, vanishPos.y, dotR, 0, Math.PI * 2);
                            ctx.fill();
                            // --- END MODIFICATION ---

                            document.body.style.cursor = 'default';
                            msg.textContent = 'Click the red dot.'; // Simplified prompt

                            driftGuard = { armed: false, start: null, moved: false };
                            isTrialActive = true;

                            clickPhase = { active: true, timeoutId: null };

                            const cleanup = () => { // Parameter 'message' removed
                                if (!clickPhase.active) return; // Prevent double-cleanup
                                clickPhase.active = false;
                                isTrialActive = false;
                                canvas.removeEventListener('mousedown', onMouseDown);
                                document.removeEventListener('mousemove', onMouseMove);
                                document.removeEventListener('click', onClick, true);
                                clearTimeout(clickPhase.timeoutId);
                            };


                            onMouseDown = (e) => {
                                if (!isTrialActive || !clickPhase.active || e.button !== 0) return;
                                driftGuard.start = getMousePosOnCanvas(e);
                                driftGuard.armed = true;
                                driftGuard.moved = false;
                            };

                            onMouseMove = (e) => {
                                if (!isTrialActive || !clickPhase.active || !driftGuard.armed) return;
                                const pos = getMousePosOnCanvas(e);
                                const dx = pos.x - driftGuard.start.x;
                                const dy = pos.y - driftGuard.start.y;
                                if ((dx * dx + dy * dy) >= (DRIFT_GUARD_THRESHOLD * DRIFT_GUARD_THRESHOLD)) {
                                    driftGuard.moved = true;
                                    cleanup();
                                    handleError('Mouse moved during response. Please click "Continue" to restart.', resolve);
                                }
                            };

                            onClick = (e) => {
                                if (!isTrialActive || !clickPhase.active || e.button !== 0) return;
                                if (fullscreenInterrupted) { cleanup(); return; }
                                if (driftGuard.moved) return;

                                const clickPos = getMousePosOnCanvas(e);
                                const closest = findClosestPointOnPath(tr, clickPos);

                                // "Click Too Far" logic (Orthogonal error check)
                                const p_before = Math.max(0, Math.min(1, closest.p - 0.001));
                                const p_after = Math.max(0, Math.min(1, closest.p + 0.001));
                                const tan_amp = (tr.pathGeometry === 'sinusoidal') ? pathWidth * SINE_AMPLITUDE : 0;
                                const phase = tr.phaseOffset || 0;

                                const angle_before = (tr.pathGeometry === 'sinusoidal') ? (SINE_CYCLES * p_before * 2 * Math.PI + phase) : 0;
                                const angle_after = (tr.pathGeometry === 'sinusoidal') ? (SINE_CYCLES * p_after * 2 * Math.PI + phase) : 0;

                                const point_before = definition.getPoint(p_before, tan_amp, angle_before);
                                const point_after = definition.getPoint(p_after, tan_amp, angle_after);

                                const tangent = { x: point_after.x - point_before.x, y: point_after.y - point_before.y };
                                const mag = Math.hypot(tangent.x, tangent.y);
                                const unitTangent = (mag > 0) ? { x: tangent.x / mag, y: tangent.y / mag } : pathDefs[tr.motionPath].dir;
                                const unitNormal = { x: -unitTangent.y, y: unitTangent.x };

                                const clickVector = { x: clickPos.x - closest.point.x, y: clickPos.y - closest.point.y };
                                const orthErr = clickVector.x * unitNormal.x + clickVector.y * unitNormal.y;

                                const acceptanceThreshold_px = CLICK_SNAP_PX; // 0.5cm

                                if (Math.abs(orthErr) > acceptanceThreshold_px) {
                                    msg.textContent = 'Click was too far from the path. Please try again.';
                                    // Reset drift guard but keep listeners active
                                    driftGuard.armed = false;
                                    driftGuard.moved = false;
                                    // Do NOT cleanup, resolve, or record. Just wait for the next click.
                                    return;
                                }

                                // --- Click is VALID ---
                                cleanup(); // Stop listeners

                                // --- PRACTICE MODIFICATION: NO DATA RECORDING ---

                                clearCanvas();
                                drawTrack(tr); // Redraw track for final display

                                // Visualize the response at the snapped point
                                ctx.fillStyle = '#000000';
                                ctx.beginPath();
                                ctx.arc(closest.point.x, closest.point.y, dotR, 0, Math.PI * 2);
                                ctx.fill();
                                msg.textContent = 'Response recorded.';

                                onFullscreenInterrupt = null;

                                nextTrialBtn.style.display = 'block';
                                nextTrialBtn.addEventListener('click', () => {
                                    nextTrialBtn.style.display = 'none';
                                    resolve(true); // resolve(true) signals success
                                }, { once: true });
                            };

                            // Arm listeners for response phase
                            canvas.addEventListener('mousedown', onMouseDown);
                            document.addEventListener('mousemove', onMouseMove);
                            document.addEventListener('click', onClick, true);

                            // Timeout for the *entire* response phase
                            clickPhase.timeoutId = setTimeout(() => {
                                cleanup();
                                // --- PRACTICE MODIFICATION: NO TIMEOUT RECORDING ---
                                handleError('Time expired. Please click "Continue" to restart.', resolve);
                            }, RESPONSE_WINDOW_MS);

                        } // end if (vanished)

                        accumulatedTime -= FRAME_INTERVAL;
                    } // end while loop

                    // This block runs *after* the logic updates, to draw the frame
                    if (!vanished) {
                        clearCanvas();

                        // Draw track ONLY IF the trial condition is 'visible'
                        if (tr.pathVisibility === 'visible') {
                            drawTrack(tr);
                        }

                        // Calculate current dot position based on *totalElapsed* time
                        const distTravelled = speed_px_ms * totalElapsed + randomStartOffsetPx;

                        if (distTravelled < totalPathLength) {
                            const distFromStart = (tr.direction === 1) ? distTravelled : (totalPathLength - distTravelled);
                            const p_norm = Math.max(0, Math.min(1, getPAtArcLength(tr, distFromStart)));

                            const amp = (tr.pathGeometry === 'sinusoidal') ? pathWidth * SINE_AMPLITUDE : 0;
                            const angle = (tr.pathGeometry === 'sinusoidal') ? (SINE_CYCLES * p_norm * 2 * Math.PI + (tr.phaseOffset || 0)) : 0;
                            const currentPos = definition.getPoint(p_norm, amp, angle);

                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.arc(currentPos.x, currentPos.y, dotR, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }; // end frame function

                animationFrameId = requestAnimationFrame(frame);

            });
        }

        // --- Experiment Flow ---
        async function startExperiment() {
            const allPossibleTrials = buildTrials(); // Builds the 5 practice trials

            if (running) return;
            running = true;
            downloadBtn.disabled = true;
            experimentStartTimeCET = new Date().toLocaleString('en-GB', { timeZone: 'Europe/Malta' });

            DURATION_SEC = parseFloat(tInput.value) || 3.7;
            const BLANK_MS = FIXED_BLANK_MS;
            SINE_AMPLITUDE = parseFloat(ampInput.value) || 0.05;
            SINE_CYCLES = parseFloat(cyclesInput.value) || 3;

            // Build arc-length caches using current geometry
            allPossibleTrials.forEach(tr => buildArcLengthCache(tr));

            // Compute a single constant *base* speed (px/ms)
            const totals = allPossibleTrials.map(tr => {
                const key = `${tr.motionPath}-${tr.pathGeometry}-${(tr.phaseOffset || 0).toFixed(4)}`;
                if (!arcLengthCache[key]) {
                    console.error("Cache key not found:", key);
                    return 0;
                }
                return arcLengthCache[key].total;
            });
            const minPathLen = Math.min(...totals.filter(t => t > 0)); // Filter out 0s if any

            if (!minPathLen || minPathLen <= 0) {
                console.error("Could not calculate path length. Canvas may be 0x0.");
                msg.textContent = "Error: Could not start experiment. Please refresh.";
                return;
            }

            const estimatedFullDurationMs = (DURATION_SEC * 1000);
            BASE_SPEED_PX_PER_MS = minPathLen / estimatedFullDurationMs;


            dataRecords = []; // Array is not used, but code expects it
            trials = allPossibleTrials;
            const totalTrials = trials.length; // 5

            // --- PRACTICE 1 INSTRUCTIONS ---
            ovlTitle.textContent = 'Practice 1: Instructions';
            ovlBody.innerHTML = `This is the first practice block.
    <br><br>Your task is to track the moving dot with your eyes.
    <br><br>The dot will vanish. After a brief pause, a red dot will appear where it vanished.
    <br><br>Your task is to <strong>click the red dot</strong>. This will help you get used to clicking on the path.
    <br><br><strong>Important:</strong> Please do NOT move your mouse</b> from the moment a trial begins until you are asked to click.
    <br><br>The practice consists of ${totalTrials} trials.`;
            overlay.style.display = 'flex';
            await waitContinue();
            overlay.style.display = 'none';

            // freeze canvas size for the entire run (prevents resizing when FS is lost)
            FREEZE_CANVAS_SIZE = true;
            resizeCanvas(); // One last resize while frozen

            let trialIndex = 0;
            while (trialIndex < totalTrials) {
                // No need to de-conflict trials in a 5-trial practice

                const tr = trials[trialIndex];
                tr.idx = trialIndex + 1;

                clearCanvas();
                msg.textContent = `Practice Trial ${tr.idx}/${totalTrials}`;
                await delay(INTER_TRIAL_BLANK_MS);

                document.body.style.cursor = 'none';

                await delay(sampleDelay(PRE_STIMULUS_DELAY)); // 500-1000ms delay

                const trialSuccessful = await runOneTrial(tr, totalTrials);

                if (trialSuccessful === true) {
                    trialIndex++; // Only advance to next trial if successful

                    // --- PRACTICE MODIFICATION: REMOVED TRIAL BLOCK BREAKS ---

                } else {
                    // --- Trial Failed (Mouse, Timeout, or FS Exit) ---
                    if (fullscreenInterrupted) {
                        msg.textContent = `Fullscreen was exited. Please click “Return to Fullscreen” to continue Trial ${tr.idx}/${totalTrials}.`;
                        await waitForFullscreen();
                        fullscreenInterrupted = false;
                    }

                    // For practice, just retry the same trial. No swapping.
                }
            }

            // --- PRACTICE MODIFICATION: NO DATA DOWNLOAD ---
            // downloadBtn.disabled = false;
            // autoDownload();

            ovlTitle.textContent = 'Practice 1 Complete!';
            ovlBody.innerHTML = 'Thank you for completing the first practice. <br><br>Please click the Finish button to proceed to Practice 2.';
            continueBtn.textContent = 'Finish';
            overlay.style.display = 'flex';
            continueBtn.addEventListener('click', () => {
                if (document.fullscreenElement) document.exitFullscreen().catch(() => { });

                // mark as finalized so no other timeouts can change the UI text
                EXPERIMENT_FINALIZED = true;

                try { if (animationFrameId) cancelAnimationFrame(animationFrameId); } catch { }

                // hide overlays/buttons, reset cursor, clear canvas, and set the final message
                overlay.style.display = 'none';
                nextTrialBtn.style.display = 'none';
                fsExitOverlay.style.display = 'none';
                document.body.style.cursor = 'default';
                if (typeof clearCanvas === 'function') clearCanvas();
                msg.textContent = 'Thank you!';
                startNextPhase();

            }, { once: true });


            // unfreeze canvas after experiment ends
            FREEZE_CANVAS_SIZE = false;

            running = false;
        }

        //IMT Navigate
        function startNextPhase() {


            var pageString = "E1_Practice_2_NoFeedback.html?ID=";
            // var pageString = "obtainConsent.html?ID=";
            var secondString = "&SESSION=";
            var finalURL = pageString + sessionStart.toString() + secondString + sessionKey.toString() + sourceString + dataString;

            window.location.href = finalURL;

        }


        // --- Data Handling ---
        function convertToCSV(data) {
            // This function is not used in practice, but left for code integrity
            if (!data || data.length === 0) return '';
            const allKeysSet = new Set();
            for (const row of data) {
                Object.keys(row).forEach(k => allKeysSet.add(k));
            }
            const preferredOrder = [
                'trial', 'motionPath', 'pathGeometry', 'direction', 'pathVisible',
                'experiment_start_time',
                'vanishP', 'vanishX_px', 'vanishY_px', 'clickX_px', 'clickY_px', 'snappedX_px', 'snappedY_px',
                'errorFwd_px', 'errorOrth_px', 'errorTemp_ms',
                'errorEuclidean_px', 'isOutlier',
                'speed_px_s', 'speed_px_ms_actual', 'startOffset_px',
                'break_started_at', 'experiment_end_time'
            ];
            const allKeys = Array.from(allKeysSet);
            const headers = [
                ...preferredOrder.filter(k => allKeysSet.has(k)),
                ...allKeys.filter(k => !preferredOrder.includes(k))
            ];
            const headerRow = headers.join(',');
            const rows = data.map(row =>
                headers.map(h => JSON.stringify(row[h] ?? '')).join(',')
            );
            return [headerRow, ...rows].join('\n');
        }


        function autoDownload() {
            // --- PRACTICE MODIFICATION: DO NOT DOWNLOAD ---
            return;
        }

        downloadBtn.addEventListener('click', autoDownload);

        resizeCanvas();
    </script>
</body>

</html>