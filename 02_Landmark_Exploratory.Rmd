---
title: "The Landmark Test - Exploratory Analysis"
author: "Laura Engels"
date: "2026-01-11"
output:
  html_document:
    toc: true
    toc_depth: 3
    theme: united
    code_folding: hide
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: '3'
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(eval = FALSE, echo = TRUE, message = FALSE, warning = FALSE)

library(tidyverse)
library(lme4)
library(lmerTest)
library(emmeans)
library(minpack.lm) 
```

# Prep
```{r load-and-clean}
# Note: Path is generic for privacy
file_path <- "data/raw_data/experiment_1_horizontal.csv"
df <- read_csv(file_path, show_col_types = FALSE)

df_clean <- df %>% 
  # Robust outlier filtering (handles "TRUE"/TRUE)
  mutate(isOut = as.logical(isOutlier)) %>%
  filter(is.na(isOut) | !isOut) %>%
  mutate(
    fileID = as.factor(fileID),
    pathGeometry = as.factor(pathGeometry),
    pathVisible = as.factor(pathVisible),
    direction = as.factor(direction),
    
    # CONTRAST CODING 
    # numeric codes, MUST specify values in emmeans later.
    pathVisibleC = ifelse(pathVisible == "visible", 0.5, -0.5),
    pathGeometryC = ifelse(pathGeometry == "sinusoidal", 0.5, -0.5)
  )
```

## Part 1: Global Geometry Effect
## Question: Does the sinusoidal shape itself disrupt momentum compared to linear paths?

```{r model-global-geometry}
print("--- GLOBAL MODEL RESULTS (Singularity Fixed) ---")

# We use || to remove correlations between random effects, preventing singular fits.
model_global <- lmer(errorFwd_px ~ pathGeometryC * pathVisibleC + 
                       (1 + pathGeometryC * pathVisibleC || fileID), 
                     data = df_clean,
                     control = lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5)))

cat("\n--- SINGULARITY CHECK (Global Model) ---\n")
is_sing <- isSingular(model_global)
print(is_sing)
if(is_sing) cat("WARNING: Model is Singular! Parameters may be unreliable.\n")

print(anova(model_global))

print("--- POST-HOC: Geometry x Visibility ---")
emmeans(model_global, 
        pairwise ~ pathVisibleC | pathGeometryC,
        at = list(pathVisibleC = c(-0.5, 0.5),
                  pathGeometryC = c(-0.5, 0.5)))

appendix_list <- list()

# Helper function to format ANOVA results with MSE for the text
report_effect_text <- function(model, effect_name) {
  res <- nice(model, mse = TRUE, correction = "none") 
  row <- res[res$Effect == effect_name, ]
  
  if (nrow(row) == 0) return(paste("Effect", effect_name, "not found."))
  
  f_val <- row$F
  df1 <- row$df
  df2 <- row$df.error
  p_val <- row$p
  eta <- row$ges
  mse <- row$MSE
  
  p_text <- ifelse(p_val < .001, "p < .001", paste0("p = ", sub("^(-?)0.", "\\1.", sprintf("%.3f", p_val))))
  
  sprintf("F(%s, %s) = %s, %s, MSE = %s, ges = %s", 
          df1, df2, f_val, p_text, mse, eta)
}
```

##Part 2: The Landmark Test (Derivative Method)
##Question: Do turning points (Peaks) act as landmarks?

```{r define-sine-function}
# DEFINE SINE FITTING FUNCTION
fit_sine_wave <- function(df_subset) {
  x <- df_subset$vanishX_px
  y <- df_subset$vanishY_px
  
  # Initial Guesses
  A_init <- (max(y, na.rm=TRUE) - min(y, na.rm=TRUE)) / 2
  c_init <- mean(y, na.rm=TRUE)
  x_range <- max(x, na.rm=TRUE) - min(x, na.rm=TRUE)
  if(x_range == 0) x_range <- 1
  k_init <- 2 * pi / x_range
  
  tryCatch({
    m <- nlsLM(vanishY_px ~ c + A * sin(k * vanishX_px + phi),
               data = df_subset,
               start = list(c = c_init, A = A_init, k = k_init, phi = 0),
               control = nls.lm.control(maxiter = 200))
    return(t(coef(m)))
  }, error = function(e) return(data.frame(c=NA, A=NA, k=NA, phi=NA)))
}

# FIT SINE WAVE PER PARTICIPANT & DIRECTION
df_sin_params <- df_clean %>%
  filter(pathGeometry == "sinusoidal") %>%
  group_by(fileID, direction) %>%
  do(as.data.frame(fit_sine_wave(.))) %>%
  ungroup()

# CALCULATE DERIVATIVES & LABEL REGIONS
# FIX: Now grouping by 'fileID' AND 'direction' for correct thresholding
df_derivative <- df_clean %>%
  filter(pathGeometry == "sinusoidal") %>%
  left_join(df_sin_params, by = c("fileID", "direction")) %>%
  filter(!is.na(k)) %>% 
  mutate(
    theta = k * vanishX_px + phi,
    slope = A * k * cos(theta),
    abs_slope = abs(slope),
    # Define Top/Bottom relative to the sine center 'c'
    vertical_pos = ifelse(vanishY_px < c, "Top", "Bottom") 
  ) %>%
  # Group by Direction too
  group_by(fileID, direction) %>%
  mutate(
    # Threshold: flattest 15% of THIS specific trajectory type
    slope_thresh = quantile(abs_slope, 0.15, na.rm = TRUE),
    
    LandmarkRegion = case_when(
      abs_slope <= slope_thresh & vertical_pos == "Top" ~ "Top Peak",
      abs_slope <= slope_thresh & vertical_pos == "Bottom" ~ "Bottom Peak",
      TRUE ~ "Slope"
    )
  ) %>%
  ungroup()

# Set Reference Level
df_derivative$LandmarkRegion <- relevel(as.factor(df_derivative$LandmarkRegion), ref = "Slope")
# Ensure coding is present
df_derivative$pathVisibleC <- ifelse(df_derivative$pathVisible == "visible", 0.5, -0.5)

print("--- LANDMARK REGION COUNTS ---")
table(df_derivative$LandmarkRegion)
```

#Landmark Statistical Model & Plot

```{r calc-derivatives, plot-landmark-regions, fig.cap="Forward Error by Landmark Region", fig.height=5, fig.width=7}
# random slopes for Visibility (lots of data) but not Landmarks (sparse data)
# add 'direction' as a fixed effect to control for left-right 

print("--- LANDMARK MODEL RESULTS ---")
model_landmark <- lmer(errorFwd_px ~ LandmarkRegion * pathVisibleC + direction + 
                         (1 + pathVisibleC | fileID), 
                       data = df_derivative,
                       control = lmerControl(optimizer = "bobyqa"))

cat("\n--- SINGULARITY CHECK (Landmark Model) ---\n")
print(isSingular(model_landmark))

print(summary(model_landmark))

print("--- POST-HOC: Landmark Regions ---")
emmeans(model_landmark, 
        pairwise ~ LandmarkRegion | pathVisibleC,
        at = list(pathVisibleC = c(-0.5, 0.5)))

# Create the Plot
df_derivative %>%
  group_by(LandmarkRegion, pathVisible) %>%
  summarise(
    mean_error = mean(errorFwd_px),
    se_error = sd(errorFwd_px) / sqrt(n()),
    .groups = "drop"
  ) %>%
  ggplot(aes(x = LandmarkRegion, y = mean_error, fill = pathVisible)) +
  geom_bar(stat = "identity", position = position_dodge(0.9), alpha = 0.8) +
  geom_errorbar(aes(ymin = mean_error - se_error, ymax = mean_error + se_error),
                position = position_dodge(0.9), width = 0.25) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_minimal() +
  labs(
    title = "Forward Error by Landmark Region (Derivative Method)",
    subtitle = "Comparing Top/Bottom Peaks (Flat Slope) vs. Slope (Steep Slope)",
    y = "Forward Error (px)",
    x = "Region"
  )
```
#Part 3: Mechanisms
##eQuestions: Does Speed matter?
## Does response latency relate to overshoot?

```{r mechanisms-speed-latency}
if("speed_px_s" %in% names(df_clean)){
  print("--- MECHANISM: SPEED ---")
  model_mech <- lmer(errorFwd_px ~ pathGeometryC * speed_px_s + (1 | fileID), 
                     data = df_clean,
                     control = lmerControl(optimizer = "bobyqa"))

 cat("\n--- SINGULARITY CHECK (Global Model) ---\n")
is_sing <- isSingular(model_global)
print(is_sing)
if(is_sing) cat("WARNING: Model is Singular! Parameters may be unreliable.\n")


  print(summary(model_mech))
}

# MECHANISM CHECK: Response Latency
# Question: Does taking longer to respond (higher latency) lead to more overshoot?

if("errorTemp_ms" %in% names(df_clean)){
  print("--- MECHANISM: LATENCY (Response Time) ---")
  
  # We scale() the time variable to prevent convergence errors (ms are large numbers)
  model_latency <- lmer(errorFwd_px ~ pathGeometryC * pathVisibleC + scale(errorTemp_ms) + 
                          (1 | fileID), 
                        data = df_clean,
                        control = lmerControl(optimizer = "bobyqa"))
  
  cat("\n--- SINGULARITY CHECK (Global Model) ---\n")
is_sing <- isSingular(model_global)
print(is_sing)
if(is_sing) cat("WARNING: Model is Singular! Parameters may be unreliable.\n")

  
  print(summary(model_latency))
  
}
```

# Part 4: Robustness Checks
# Question: Do results depend on the arbitrary 15% cutoff?

```{r robustness}
print("--- ROBUSTNESS 1: SENSITIVITY TO CUTOFF (10%, 15%, 20%) ---")

# Loop through different quantiles to show pattern stability
for (q in c(0.10, 0.15, 0.20)) {
  tmp <- df_derivative %>%
    group_by(fileID, direction) %>%
    mutate(slope_thresh = quantile(abs_slope, q, na.rm=TRUE),
           # Define Binary "Turning vs Slope" for this check
           Turning = abs_slope <= slope_thresh) %>%
    ungroup()
  
  # test the general effect of "Turning Regions" vs Slopes
  m_robust <- lmer(errorFwd_px ~ Turning * pathVisibleC + direction + (1|fileID), 
                   data=tmp,
                   control = lmerControl(optimizer = "bobyqa"))
  
  cat("\n--- Quantile Cutoff:", q, "---\n")
  print(anova(m_robust))
}

print("--- ROBUSTNESS 2: CONTINUOUS SLOPE ANALYSIS ---")
# If slope matters, we should see a relationship without ANY binning.
# Flatter slope (near 0) = Turning Point. Steeper slope = Slope Region.
# test if error scales with absolute slope.

model_cont <- lmer(errorFwd_px ~ abs_slope * pathVisibleC + direction + (1 | fileID), 
                   data = df_derivative,
                   control = lmerControl(optimizer = "bobyqa"))

cat("\n--- SINGULARITY CHECK (Continuous Model) ---\n")
print(isSingular(model_cont))

print(summary(model_cont))


df_derivative %>%
  group_by(LandmarkRegion) %>%
  summarise(
    Mean = mean(errorFwd_px),
    Median = median(errorFwd_px),
    Overshoot_Rate = mean(errorFwd_px > 0) * 100, # Percentage of trials > 0
    SD = sd(errorFwd_px)
  )
```
## Caveat: binning can change conclusions depending on where you put boundaries; known issue in methods.

# THESIS APPENDIX TABLES

```{r appendix_tables, echo=TRUE, results='asis'}
print_apa_table <- function(df, table_num, title, note) {
  
  if("Pr(>|t|)" %in% names(df)) df <- df %>% rename(p = `Pr(>|t|)`)
  if("t value" %in% names(df)) df <- df %>% rename(t = `t value`)
  if("Std. Error" %in% names(df)) df <- df %>% rename(SE = `Std. Error`)
  if("Pr(>F)" %in% names(df)) df <- df %>% rename(p = `Pr(>F)`)
  
  df <- df %>% mutate(across(where(is.numeric), ~ round(., 3)))
  
  # Format p-values specifically
  if("p" %in% names(df)) {
    df$p <- ifelse(as.numeric(df$p) < .001, "< .001", 
                   sub("^(-?)0.", "\\1.", sprintf("%.3f", as.numeric(df$p))))
  }

  # Add Row Names as a proper column for Betas
  if(!is.null(row.names(df)) && row.names(df)[1] != "1") {
    df <- tibble::rownames_to_column(df, "Predictor")
  }

  n_cols <- ncol(df)
  align_vec <- c("l", rep("c", n_cols - 1))
  
  cat(paste0("\n\n**Table ", table_num, "**\n\n"))
  cat(paste0("*", title, "*\n\n"))
  
  print(knitr::kable(df, 
                     format = "html", 
                     align = align_vec,
                     row.names = FALSE,
                     table.attr = "style='width:100%; border-top: 2px solid black; border-bottom: 2px solid black; border-collapse: collapse;'"))
  
  cat(paste0("\n*Note.* ", note, "\n"))
  cat("\n<br><br>\n")
}

# Table F.13: Descriptive Statistics 
desc_stats <- df_derivative %>%
  group_by(LandmarkRegion) %>%
  summarise(
    N_Trials = n(),
    Mean = mean(errorFwd_px, na.rm = TRUE),
    SD = sd(errorFwd_px, na.rm = TRUE),
    SE = SD / sqrt(n())
  )

print_apa_table(desc_stats, "F.13", 
                "Descriptive Statistics of Forward Error by Landmark Region", 
                "Comparison of turning points (Peaks) vs. trajectory slopes.")

# Table : LMM F-Tests (Landmark Model) 
anova_landmark <- as.data.frame(anova(model_landmark, ddf = "Kenward-Roger"))
print_apa_table(anova_landmark, "F.14", 
                "LMM Type III Wald F-tests: Categorical Landmark Analysis", 
                "Tests if error differs between Top Peak, Bottom Peak, and Slope regions.")

# Table G.3: LMM Betas (Landmark Model) 
betas_landmark <- as.data.frame(summary(model_landmark)$coefficients)
print_apa_table(betas_landmark, "F.15", 
                "LMM Fixed Effects Estimates: Categorical Landmark Analysis", 
                "Reference level for Region is 'Slope'. Contrast compares Peaks against the Slope.")

# Table G.4: LMM Continuous Robustness Check 
betas_cont <- as.data.frame(summary(model_cont)$coefficients)
print_apa_table(betas_cont, "F.16", 
                "LMM Fixed Effects: Continuous Slope Analysis (Robustness Check)", 
                "Tests if forward error scales linearly with the absolute slope of the trajectory derivative.")

# Table G.5: Simple Effects (if Interaction is significant)
# Only creating the dataframe here, you can decide to include if p < .05
emmeans_land <- emmeans(model_landmark, ~ LandmarkRegion | pathVisibleC)
contrasts_land <- as.data.frame(contrast(emmeans_land, method = "pairwise", adjust = "holm"))

print_apa_table(contrasts_land, "F.17", 
                "Pairwise Comparisons of Landmark Regions", 
                "Holm-corrected comparisons within visibility conditions.")
```


